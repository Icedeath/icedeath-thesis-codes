function [a,phi_NL,f]=int_inf(y_f,fc,fs)
y_h=hilbert(y_f);

a=abs(y_h);   %瞬时幅度

phi = atan2(real(y_h),imag(y_h));

phi_NL=phi-mod(2*pi*((1:length(phi))-1)*fc/fs,2*pi);%去掉线性分量的瞬时相位

f(1)=fs*(phi_NL(2)-phi_NL(1))/(2*pi);
f(2:length(phi_NL))=fs*diff(phi_NL)/(2*pi);

% hyr=hilbert(y_f);
% 
% %求瞬时幅度
% a=abs(hyr);
% 
% %求瞬时相位
% phi_phase=angle(hyr);
% c_k(1)=0;%修正相位序列
% for i=2:length(phi_phase)
%     if phi_phase(i)-phi_phase(i-1)>pi
%         c_k(i)=c_k(i-1)-2*pi;
%     elseif phi_phase(i-1)-phi_phase(i)>pi
%         c_k(i)=c_k(i-1)+2*pi;
%     else c_k(i)=c_k(i-1);
%     end
% end
% c_k;
% phi_uw_phase=phi_phase+c_k;%去卷叠相位
% phi_NL_phase=phi_uw_phase-2*pi*((1:length(phi_phase))-1)*fc/fs;%去相位线性分量后真正的瞬时相位
% phi_NL_phase1=mod(phi_NL_phase,2*pi);
% for i=1:length(phi_NL_phase)
%     if phi_NL_phase1(i)>1.9*pi
%         phi_NL_phase2(i)=phi_NL_phase1(i)-2*pi;
%     else phi_NL_phase2(i)=phi_NL_phase1(i);
%     end
% end
% 
% %求瞬时频率
% f_frequency(1)=fs*(phi_NL_phase(2)-phi_NL_phase(1))/(2*pi);
% f_frequency(2:length(phi_NL_phase))=fs*diff(phi_NL_phase)/(2*pi);